---
title: 浏览器工作原理—05输入URL到页面的渲染流程
date: 2021/6/4
tags:
categories: 浏览器工作原理与实践
---

# 05 | 渲染流程：HTML、CSS 和 JavaScript，是如何变成页面的？

- 上文介绍了导航相关的流程，导航提交之后进入渲染阶段，即 HTML、CSS 和 JavaScript，是如何变成页面的？
- 由于渲染机制过于复杂，渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出为像素，这个过程为渲染流水线

## 渲染流水线

- 渲染流水线可分为如下子阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成
- 需注意每个子阶段都有其输入的内容、然后每个子阶段都有其处理过程、最终每个子阶段会生成输出内容

### 1. 构建 DOM 树

- 由于浏览器无法直接理解和使用 HTML，所以就需要将 HTML 转换为浏览器能够理解的结构——DOM 树
- 树结构中每个点称为节点，相连的节点称为父子节点，如下图为 DOM 树的构建过程
  {% asset_img DOM树的构建过程.png DOM树的构建过程 %}
- 由上图可知：构建 DOM 树的输入内容为 HTML 文件，然后经过 HTML 解析器，最终输出树状结构的 DOM
- 可在 chrome 里的控制台 console 里输入 document，即可看到完整的 DOM 树结构

### 2. 样式计算（Recalculate Style）

- 样式计算是为了计算出 DOM 节点中每个元素的具体样式，该阶段可分为三步来完成：

1. 把 CSS 转换为浏览器能够理解的结构

- CSS 样式来源主要有三种：通过 link 引用的外部 CSS 文件、style 标签内的文件、元素 style 属性内嵌的 CSS
- 浏览器也无法直接理解和使用 CSS 样式的，同样也需要渲染引擎执行转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets
- 控制台 console 里输入 document.styleSheets 可查看结构

2. 转换样式表中的属性值，使其标准化

- 当 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值（px,rgba,font-weight），这个过程就是属性值标准化

3. 计算出 DOM 树中每个节点的具体样式

- 标准化之后，就需要计算 DOM 树中每个节点的样式属性
- 涉及 CSS 的继承规则和层叠规则
  - CSS 继承就是每个 DOM 节点都包含有父节点的样式
  - 层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点

### 3. 布局阶段

- 有了 DOM 树和 DOM 树中元素的样式，就要计算出 DOM 节点可见元素的几何位置信息，这个计算过程即为布局
- 布局分为两个任务：创建布局树和布局计算
  1. 创建布局树
  - DOM 树中还有很多不可见的元素，如 head 标签，还有使用了`display:none` 属性的元素，在显示之前，我们还需要额外生成只包含可见元素的布局树
    - 遍历 DOM 树中的所有可见节点，并把这些节点加到布局中
    - 而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容
  2. 布局计算
  - 获取到布局树之后，需要计算布局树节点坐标位置

### 4. 分层

- 在绘制页面之前还需要处理页面中可能存在的复杂效果，如 3D 变换、页面滚动、使用 z-index 做 Z 轴排序等，为了更加方便实现这些效果，渲染引擎还需要为特定的节点生成专用图层，并生成一颗对应的图层树（类似 PS 中的图层）
- 打开 chrome 控制台中的 Layers 即可看到可视化页面的分层情况
- 浏览器的页面分为很多图层，这些图层叠加后合成了最终的页面
- 通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层
- 满足下面两点中任一点的元素会被渲染引擎单独生成一个图层

  1. 拥有层叠上下文属性的元素会被提升为单独的一层

  - 明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性

  2. 需要剪裁（clip）的地方也会被创建为图层

  - 当内容过多超出盒子大小，就会产生剪裁，如果出现滚动条，滚动条也会被提升为一个图层

### 5. 图层绘制

- 在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制
- 渲染引擎会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表
- 绘制阶段就是将输入图层，经过拆分，输出绘制指令

### 6. 栅格化（raster）操作

- 绘制列表只是记录绘制顺序和绘制指令的列表，
  而实际上绘制操作是由渲染引擎上的合成线程来完成的
- 当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程
- 首先需要了解下视口，视口 ViewPort 就是页面上可见的区域，有时候有的图层可能很大，需要在页面上使用滚动条滚动好久才能移动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要
- 所以合成线程会把图层划分为图块，图块的大小通常为 256 _ 256 或者 512 _ 512
- 合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图
- 栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中（涉及跨进程操作）

### 7. 合成和显示

- 当所有图块被光栅化，合成线程就会生成一个绘制图块的命令——`DrawQuad`，然后将该命令提交给浏览器进程
- 浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上

## 总结

- 整个渲染流程图
  {% asset_img 渲染过程.png 渲染过程 %}
- 结合上图，一个完整的渲染流程大致可总结为如下：

1. 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式
3. 创建布局树，并计算元素的布局信息
4. 对布局树进行分层，并生成分层树
5. 为每个图层生成绘制列表，并将其提交到合成线程
6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图
7. 合成线程发送绘制图块命令 DrawQuad 给浏览器进程
8. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上

## 相关概念：重排、重绘和合成

### 更新了元素的几何属性（重排）

- 更新元素的几何属性
  {% asset_img 重排.png 重排 %}
- 从上图可以看出，如果通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的

### 更新元素的绘制属性（重绘）

- 更新元素的绘制属性
  {% asset_img 重绘.png 重绘 %}
- 从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些

### 直接合成阶段

- 更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，这个过程叫做合成
  {% asset_img 合成.png 合成 %}
- 在上图中，我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率
