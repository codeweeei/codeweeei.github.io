---
title: 单线程、任务事件及事件循环
date: 2020/12/16
tags: 前端面试
categories: Javascript
---

## <b>Js 的运行机制</b>

### <b style="color:pink">单线程</b>

- JavaScript 语言的一大特点就是单线程，也就是说，<span style="color:red">同一个时间只能做一件事。</span>
- 为什么不允许 js 可以实现多线程？因为如果实现了多线程，一个线程创建了一个 div 元素，而另外一个线程删除了这个 div 元素，那么这个时候浏览器应该听谁的？
- 所以为了避免出现这种互相冲突的操作，js 从一开始就是单线程的，这就是它的核心特征。

### <b style="color:pink">任务队列</b>

- 单线程就意味着，所有任务需要排队，<span style="color:red">前一个任务结束，才会执行后一个任务。</span>如果前一个任务耗时很长，后一个任务就不得不一直等着。
  - 如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 设备（输入输出设备）很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。
  - JavaScript 语言的设计者意识到，<span style="color:red">这时主线程完全可以不管 IO 设备，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 设备返回了结果，再回过头，把挂起的任务继续执行下去。</span>
  - 于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。
- "任务队列"中的事件，除了 IO 设备的事件以外，包含定时器事件，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入"任务队列"，等待主线程读取。

### <b style="color:pink">同步和异步任务</b>

- <span style="color:red">同步任务</span>指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；
- <span style="color:red">异步任务</span>指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。
  1. 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
  2. 主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
  3. 一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
  4. 主线程不断重复上面的第三步
- <b style="color:red">只要主线程空了，就会去读取"任务队列"，这就是 JavaScript 的运行机制。这个过程会不断重复。</b>

## <b>事件循环（Event Loop）</b>

- 主线程从"任务队列"中读取事件，这个过程是<b>循环不断</b>的，所以整个的这种运行机制又称为 Event Loop（事件循环）。
  ![eventloop](./单线程、任务队列及事件循环/eventloop.png)
- 主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部 API，它们在"任务队列"中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取"任务队列"，依次执行那些事件所对应的回调函数。

## <b>经典面试题</b>

- for 循环结合定时器，考察 <i>js 运行机制，同步异步，事件循环，闭包，var 和 let 的区别，作用域</i>等知识点；
- 例子 1：<span style="color:red;">使用 var 的 for 循环结合定时器</span>

  ```js
  for (var i = 0; i <= 3; i++) {
    setTimeout(function () {
      console.log(i)
    }, 1000)
  }
  console.log("a")
  //此时先打印出a，一秒后打印4个4
  ```

  - 解释：
    - for 循环是同步的，而定时器事件是放在任务队 列里的，当 js 代码运行到有定时器的地方的时 候，会把定时器操作放在任务队列的尾部，所以需 要等同步代码全部运行完毕之后，以及当前任务队 列里的已有事件全部完成之后，才会执行定时器的 代码，所以才会先打印出 a；
    - for 循环也已经循环完毕，虽然 for 循环每次 循环都会产生一个块级作用域，但是 var 定义的 i 是保存在全局变量里的，不存在块级作用域， 故 for 循环循环完毕之后 i 自增为 4，然后执行 放在任务队列中的定时器事件（4 次 for 循环产 生了 4 次定时器事件，每个都是 1000ms 之后打 印共享的全局变量 i），故一秒之后打印出 4 个 4；

- 例子 2：<span style="color:red;">使用 let 的 for 循环结合定时器</span>

  ```js
  for (let i = 0; i <= 3; i++) {
    setTimeout(function () {
      console.log(i)
    }, 1000)
  }
  console.log("a")
  //此时先打印出a，一秒后打印出0，1，2，3
  ```

  - 解释：
    - 先打印出 a 跟上述原因一致；
    - let 定义的存在块级作用域，故每次 for 循环都在生成一个自己的块级作用域用来保存当前的 i 值，故最后执行定时器事件时就会打印出在自己的块级作用域里的 i 值；
  - 问题：那可不可以就使用 var 定义的 for 循环里的定时器打印出 0,1,2,3 呢？
  - 解决方法：可以使用<b style="color:red">立即执行函数</b>以及<b style="color:red">闭包</b>来生成函数作用域来模拟块级作用域的效果；

- 例子 3：<span style="color:red;">使用 var 的 for 循环及立即执行函数结合定时器</span>

  ```js
  for (let i = 0; i <= 3; i++) {
    ;(function (j) {
      //这个匿名函数生成了闭包的效果，新建了一个函数作用域，这个作用域接收到每次循环的i值保存了下来，即使循环结束，闭包形成的作用域也不会被销毁
      setTimeout(function () {
        console.log(j)
      }, 1000)
    })(i)
  }
  console.log("a")
  //此时先打印出a，一秒后打印出0，1，2，3
  ```

  - 解释：
    - 先打印出 a 跟上述原因一致；
    - var 定义的不存在块级作用域，for 循环里定义的 i 变量其实暴露在全局作用域内，于是 4 个定时器里的匿名函数它们其实共享了同一个作用域里的同一个变量。
    - 利用闭包的原理，闭包使一个函数可以继续访问它定义时的作用域。而这个新生成的作用域将每一次循环的当前 i 值单独保存了下来。
