---
title: 作用域和闭包的理解
date: 2020/12/15
tags: 前端面试
categories: Javascript
---

## 作用域

### 全局作用域

- 变量在函数外定义，即为全局变量。
  全局变量有 全局作用域: 网页中所有脚本和函数均可使用。
- 全局环境是不会被回收的，除非人为回收；全局环境的用范围是全局的；

### 函数作用域

- 每次调用函数就会产生新的内存地址，函数调用完毕后，里面的内存环境就会被回收删除；
  - 延长函数环境生命周期：可以在函数调用过程中通 return 一个新的函数（使用前函数定义的数据）到函数部，即函数内部定义的数据被外部所使用，则该函数调完之后的环境也不会被回收删除；
  - 构造函数也是很好的环境例子，子函数被外部使用，父级环境也将被保留；

### 块级作用域

- 使用 let/const 可以将变量声明放在自己的块作用域（放在新的环境中，而不是全局中），注意 var 不存在块级用域特性；
- let ,const ,var 在 for 循环里的执行原理：
  - for 循环存在块级特性，每次循环都生成在一个新的块作用域，使用 var 进行 for 循环时，由于 var 不存在块级性，所以在 for 循环结束之后还是能打印 i;
  ```js
  for (var i = 1; i <= 3; i++) {
    console.log(i) //1,2,3
  }
  console.log(i) //4
  ```
  - 使用 let 进行 for 循环时，由于 let 存在块级特性，所在 for 循环结束之后不能打印 i，会报错；
  ```js
  for (let i = 1; i <= 3; i++) {
    console.log(i) //1,2,3
  }
  console.log(i) //报错：i未定义
  ```

### 作用域链

- 一般情况下，变量取值会到 创建 这个变量 的函数的作用域中取值。
- 但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。

## 闭包

### 定义

- 闭包就是可以访问到其他函数内部变量的函数；
- 在 JavaScript 中，无法在函数外部访问到函数内部的变量对象，有了闭包，即可在函数以外的任何地方访问到函数内部的变量对象。

```js
//常见的闭包形式
function fn1() {
  var a = 1,
    b = 2
  return function () {
    return a
  }
}
var fn2 = fn1()
fn2() // 1
```

- 这里 fn1 执行完成后，按理说，内部的 a、b 所在的作用域应该会销毁，但是因为闭包（匿名函数）的存在，返回的匿名函数保留了对 fn1 当前作用域的引用，因此我们可以在 fn1 执行完成之后，依然可以访问到 fn1 内部的变量 a，这就是闭包的使用。（注意，这里虽然只是 return 了 a，但是变量 b 也在内存中，也没有销毁，因为闭包保存的不是某个变量，而是整个变量对象）

### 作用

- 可以读取函数内部的变量；
- 让这些变量的值始终保持在内存中。

### 7 种形式

- 函数作为返回值被返回；
- 函数赋值（内部函数赋值给一个外部变量）；
- 函数作为参数（通过函数参数传递函数的形式）；
- IIFE 立即执行函数；
- for 循环赋值；
- 迭代器
- g(s)etter

### 内存泄露

- 闭包不能滥用，否则会导致内存泄露，影响网页的性能。闭包使用完了后，要立即释放资源，将引用变量指向 null。

### this 在闭包中的历史遗留问题

```js
//this总是指向调用函数的对象
let test = {
  username: "超威",
  getname: function () {
    return function () {
      return this.username
    }
  },
}
// console.log(test.getname()())//undefined 改行代码相当于下述代码
let a = test.getname()
console.log(a()) //a函数相当于window调用，此时this指向window，而window没有username，故打印undefined
```

- 解决方法 1：将 this 保存在一个普通变量里

```js
let test = {
  username: "超威",
  getname: function () {
    //将this保存在普通变量This里
    let This = this
    return function () {
      //该闭包可以访问上者This
      return This.username
    }
  },
}
// console.log(test.getname()())
let a = test.getname()
console.log(a()) //超威
```

- 解决方法 2：使用 ES6 的箭头函数

```js
let test = {
  username: "超威",
  getname: function () {
    return () => {
      //箭头函数本身没有this，指向它的父级作用域，而不是调用它对象，这个this的指向是不能通过call和apply改变的，但可以访问到上级中的this
      return this.username
    }
  },
}
// console.log(test.getname()())
let a = test.getname()
console.log(a()) //超威
```

### 闭包常见应用场景

- 节点循环绑定 click 事件；
- 封装私有化变量；
- 事件触发回调函数；
- 延迟处理事件；
